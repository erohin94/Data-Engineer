# **Типы физического соединения таблиц**

Зачем вообще знать, как работает физическое соединение таблиц. Все дело в том, что если у нас достаточно много задач, связанных с оптимизацией, то понимание внутренних процессов, понимание того, как работает тот или иной оператор в плане выполнения запроса, поможет нам в случае необходимости скорректировать запрос и сделать его более эффективным.

Кроме этого, на собеседованиях на позиции, которые связаны с разработкой, очень часто любят спрашивать, как работает физическое соединение таблиц, наверное в 95% случаях спросят про физическое соединение таблиц Nested Loops, Merge и Hash.

Поэтому знание и понимание того, как фактически происходит соединение данных в, очень полезно.


## **Nested Loops Join**

Nested Loops – это оператор вложенных циклов, который отражает тип физического соединения данных.

Принцип работы Nested Loops следующий: для каждого значения одного набора данных (обычно, где меньше записей), ищет соответствующее значение в другом наборе данных.

Иными словами, берем первое значение из первой таблицы (она называется внешней) и сравниваем его последовательно со всеми значениями во второй таблице (она называется внутренней), если находит соответствие, то запись включается в итоговый набор данных. Когда значение из первого набора данных сравнилось со всеми знамениями из второго набора, то берётся второе значение первого набора и снова происходит сравнение со всеми значениями из второго набора и так происходит до тех пор, пока каждое значение из первой таблицы, т.е. внешней, не будет сравнено с каждым значением из второй таблицы, т.е. внутренней.

Таким образом, у нас два цикла, внешний и внутренний, отсюда и название – вложенные циклы.

![Types_of_table_joins_in_sql_server_3](https://github.com/user-attachments/assets/6bb0bbc6-a5e2-40c3-ab5b-93ac8d1fbbc1)

В таком виде Nested Loops работает не очень эффективно, однако эффективность повышается, если данные внутренней таблицы отсортированы по соединяемому столбцу, например, если по нему создан индекс.

![Types_of_table_joins_in_sql_server_4](https://github.com/user-attachments/assets/03871306-12ed-4ef7-b41d-4f81bc73eea8)

Тип физического соединения таблиц Nested Loops обычно возникает, когда мы соединяем наборы данных, где один из наборов имеет небольшой размер, а другой набор данных сравнительно большой и индексирован по соединяемым столбцам. Nested Loops встречается достаточно часто, так как является самой быстрой операцией соединения на небольшом объеме данных.

Примечание! Если два набора данных имеют достаточно большие размеры, то данный способ соединения будет крайне неэффективен.

## **Merge Join**

Merge – соединение слиянием.

Данный тип физического соединения данных является самым быстрым, однако, он требует, чтобы оба набора данных были отсортированы, например, есть индексы по соединяемым столбцам.

Merge наиболее эффективен в тех случаях, когда два набора данных достаточно велики, и как уже было отмечено, отсортированы по соединяемым столбцам.

Принцип работы данного типа соединения следующий: получаем первые строки из каждого набора входных данных и сравниваем их. Затем продолжаем сравнение следующих строк из второго набора, до тех пор, пока значения соответствуют значению из первого набора данных. Как только значения больше не совпадают, переходим к следующей строке в наборе с меньшим значением и продолжаем выполнять сравнения.

Например, для операций внутреннего соединения строки возвращаются в том случае, если они равны. Если они не равны, строка с меньшим значением не учитывается, и из этого набора входных данных берется следующая строка и снова происходит сравнение. Этот процесс повторяется, пока не будет выполнена обработка всех строк, т.е. пока этот, назовем его, курсор, не дойдет до конца.

Данный алгоритм эффективен, потому что не должны возвращаться и читать какие-либо строки несколько раз, т.е. чтение данных происходит только один раз.

![Types_of_table_joins_in_sql_server_5](https://github.com/user-attachments/assets/3ab39eec-bd7d-40e5-ae66-710cac29a5e7)

Однако алгоритм становится менее эффективен, когда в наборах существуют повторяющиеся значения, т.е. когда происходит соединение слиянием «многие ко многим».

В таких случаях СУБД записывает любые повторяющиеся значения из второй таблицы во временную таблицу в базе данных tempdb и выполняет сравнения там. Затем, если эти значения также дублируются в первой таблице, СУБД сравнивает их со значениями, которые уже сохранены во временной таблице.

![Types_of_table_joins_in_sql_server_6](https://github.com/user-attachments/assets/54cce526-379f-434b-9e27-5ffec208863c)

Примечание! Если оба набора данных велики и имеют сходные размеры, но не отсортированы, то соединение слиянием с предварительной сортировкой и хэш-соединение (Hash) имеют примерно одинаковую производительность. Однако хэш-соединения часто выполняются быстрее, если наборы данных значительно отличаются по размеру.

## **Hash Match Join**

Hash Match – хэш-соединение.

Алгоритм соединения включает 2 фазы:

**Build**

**Probe**

В первой фазе «Build» строится хэш-таблица при помощи вычисления хэш-значения для каждой строки одного набора данных (обычно меньшего из двух). Эти хэши вычисляются на основе ключей соединения входных данных и затем сохраняются вместе со строкой в ​​хеш-таблице.

После построения хэш-таблицы начинается фаза «Probe». На этом этапе он для каждой строки другого набора данных, с помощью той же хэш-функции, вычисляет хэш-значение и осуществляет поиск совпадений по хэш-таблице. Если он находит совпадение для этого хеша, то затем он проверяет, действительно ли совпадают ключи соединения между строкой в хеш-таблице и строкой из второй таблицы (ему необходимо выполнить эту проверку из-за потенциальных хеш-коллизий).

![Types_of_table_joins_in_sql_server_7](https://github.com/user-attachments/assets/6f48c4d8-7e89-4048-8bfc-1fd9b3e43c2d)

Стоит отметить, что иногда могут возникать ситуации, когда на этапе «Build» хеш-таблица не может быть сохранена полностью в памяти. В таких случаях СУБД сохраняет некоторую часть данных в памяти, а остальную часть перенаправляет в tempdb.

Это происходит, когда объем данных превышает размер, который может храниться в памяти, или когда СУБД предоставляет недостаточный объем памяти, необходимый для соединения Hash.

![Types_of_table_joins_in_sql_server_8](https://github.com/user-attachments/assets/d950ba88-4bfb-49cc-8a06-e33eb043d8d4)

Способ физического соединения данных Hash возникает, когда мы обрабатываем большие, несортированные и неиндексированные наборы данных, при этом он делает это достаточно эффективно.
