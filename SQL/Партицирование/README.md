# **Партицирование**

Партиционирование — это способ разделить большую таблицу на несколько меньших частей, называемых партициями, которые хранятся и обрабатываются как отдельные таблицы. Однако это не означает, что каждая партиция — это полностью отдельная таблица. В PostgreSQL партиции создаются внутри одной основной таблицы и логически представляют собой подтаблицы.

**1.Создание основной таблицы (партиционированной):**

Для создания партиционированной таблицы нужно указать, что она будет использовать партиционирование по диапазону значений (например, по дате).

Так же важный момент, если указали PRIMARY KEY, например для поля order_id, то партицированный столбец также должен быть первичным ключом, иначе будет ошибка.
Ошибка с первичным ключом возникает, потому что для партиционированных таблиц PostgreSQL требует, чтобы первичный ключ был составным, включая поле, 
по которому осуществляется партиционирование (в нашем случае — order_date). Это нужно для того, чтобы гарантировать уникальность строк в рамках каждой партиции.

*Пример ошибки:*

```
CREATE TABLE orders_2 (
    order_id SERIAL PRIMARY KEY, --Первичный ключ
    order_date DATE,
    amount DECIMAL(10, 2)
) PARTITION BY RANGE (order_date);
```

![image](https://github.com/user-attachments/assets/10266fc0-bff4-42a2-85d8-9a72a5769053)

Правильный вариант:

```
--1.Создание таблицы с PRIMARY KEY, включающим order_date
-- Создаем таблицу заказов с партиционированием по дате
CREATE TABLE orders (
    order_id SERIAL,
    customer_id INT NOT NULL,
    order_date DATE NOT NULL,
    total_amount DECIMAL(10, 2) NOT NULL,
    PRIMARY KEY (order_id, order_date)  -- Включаем order_date в PRIMARY key, если не включить, то будет ошибка
) PARTITION BY RANGE (order_date);
```

После того как основная таблица создана, вы можете создавать партиции для неё, указав диапазоны значений для каждой партиции.

```
--2.Добавление партиций для каждого месяца
-- Партиция для заказов в январе 2025 года
CREATE TABLE orders_jan_2025 PARTITION OF orders
    FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

-- Партиция для заказов в феврале 2025 года
CREATE TABLE orders_feb_2025 PARTITION OF orders
    FOR VALUES FROM ('2025-02-01') TO ('2025-03-01');

-- Партиция для заказов в марте 2025 года
CREATE TABLE orders_mar_2025 PARTITION OF orders
    FOR VALUES FROM ('2025-03-01') TO ('2025-04-01');
```

Добавление тестовых данных

```
--3.Вставка тестовых данных
-- Вставляем данные для января 2025 года
INSERT INTO orders (customer_id, order_date, total_amount)
VALUES
    (1, '2025-01-05', 150.00),
    (2, '2025-01-15', 200.50),
    (3, '2025-01-20', 99.99);

-- Вставляем данные для февраля 2025 года
INSERT INTO orders (customer_id, order_date, total_amount)
VALUES
    (4, '2025-02-05', 250.00),
    (5, '2025-02-10', 350.75);

-- Вставляем данные для марта 2025 года
INSERT INTO orders (customer_id, order_date, total_amount)
VALUES
    (6, '2025-03-01', 450.00);
```

Выводим результат

```
--4.Запросы для работы с партициями
-- Запрос всех заказов
SELECT * FROM orders;

-- Запрос заказов только за февраль 2025 года
SELECT * FROM orders WHERE order_date BETWEEN '2025-02-01' AND '2025-02-28';
```

![image](https://github.com/user-attachments/assets/5363885d-61f7-4cbe-b966-e1dd64a1c722)

Сами партиции

![image](https://github.com/user-attachments/assets/a946e2d6-9345-49dc-9af0-ed7fa6a9226a)

# **Получить информацию о партициях в PostgreSQL**

Можно воспользоваться запросом, ориентированным на партиционированные таблицы, например:

```
SELECT 
    child.relname AS partition_name,
    parent.relname AS parent_table,
    child.relkind
FROM 
    pg_inherits i
JOIN 
    pg_class parent ON parent.oid = i.inhparent
JOIN 
    pg_class child ON child.oid = i.inhrelid
WHERE 
    parent.relname = 'orders';  -- Укзать имя родительской таблицы
```
Этот запрос будет использовать таблицы pg_inherits и pg_class для поиска информации о партициях, если родительская таблица существует и является партиционированной.

![image](https://github.com/user-attachments/assets/800d8655-23cc-4281-876b-4eabce448df7)

`partition_name`  — это имена партиций таблицы orders для разных месяцев 2025 года.

`orders` — это родительская таблица (основная таблица), которая используется для партиционирования. 
Каждая из партиций — это подтаблица родительской таблицы, которая хранит данные только за определённый месяц.

`relkind` - r это тип объекта в PostgreSQL (или в DBeaver). r означает "regular", то есть это обычная таблица (или партиция). 
В контексте партиционированной таблицы это обозначает, что orders_jan_2025, orders_feb_2025, и orders_mar_2025 — это партиции, а не отдельные таблицы, которые напрямую содержат данные.
