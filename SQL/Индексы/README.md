# Индексы

**Индексы** — это средство увеличения производительности БД. Используя индекс, сервер баз данных может находить и извлекать нужные строки гораздо быстрее, чем без него. 
Однако с индексами связана дополнительная нагрузка на СУБД в целом, поэтому применять их следует обдуманно.

Представим есть таблица и нам надо найти какую то запись.

Система будет сканировать всю таблицу, строку за строкой, что не очень эффективно.

Если есть индекс, то сканирование будет быстрее, так как придется опустится на несколько уровней в дереве поиска.
Это что-то наподобии оглавления в книге, чтобы найти главу, мы смотрим содержание и переходим на нужную страницу, а не листаем все страницы по порядку.

Так же, как задача автора предугадать, что именно будут искать в книге читатели, задача программиста баз данных — заранее определить, какие индексы будут полезны.

**Создать индекc:**

```
CREATE INDEX имя_индекса ON таблица(имя_столбца_для которого_создаем_индекс);
```

**Удалить индекс:**

```
DROP INDEX
```

Добавлять и удалять индексы можно в любое время.

Когда индекс создан, дополнительные действия не требуются: система сама будет обновлять его при изменении данных в таблице и сама будет использовать его в запросах, где, по её мнению, это будет эффективнее, 
чем сканирование всей таблицы.

Индексы полезны при выполнении команд UPDATE и DELETE с условиями поиска.

Кроме того, они могут применяться в поиске с соединением. То есть, индекс, определённый для столбца, участвующего в условии соединения, может значительно ускорить запросы с JOIN.

Создание индекса для большой таблицы может занимать много времени.

По умолчанию PostgreSQL позволяет параллельно с созданием индекса выполнять чтение (операторы SELECT) таблицы, но операции записи (INSERT, UPDATE и DELETE) блокируются до окончания построения индекса.

**Типы индексов**

По умолчанию CREATE INDEX создаёт индексы-B-деревья, эффективные в большинстве случаев. 
Выбрать другой тип можно, написав название типа индекса после ключевого слова USING. Например:

```
CREATE INDEX имя ON таблица USING HASH (столбец);
```

**1. B-tree**

B-деревья могут работать в условиях на равенство и в проверках диапазонов с данными, которые можно отсортировать в некотором порядке. 
Точнее, планировщик запросов PostgreSQL может задействовать индекс-B-дерево, когда индексируемый столбец участвует в сравнении с одним из следующих операторов:

```
< <= = >= >
```

Представим есть таблица

```
CREATE TABLE employees (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    salary DECIMAL
);
```

В этой таблице три столбца: id, name и salary. Индекс по умолчанию будет создан на первичном ключе (id), который представляет собой последовательность чисел и автоматически индексируется.

Предположим, мы хотим создать индекс на столбец salary, чтобы ускорить поиск сотрудников по зарплате.

```
CREATE INDEX idx_salary ON employees(salary);
```

После создания индекса PostgreSQL будет использовать его для ускорения операций с таблицей, таких как:

*Поиск по значению*

Если мы хотим найти сотрудника с зарплатой больше 50,000:

```
SELECT * FROM employees WHERE salary > 50000;
```

PostgreSQL использует индекс на столбце salary, чтобы быстро найти все строки, соответствующие этому условию. 
Без индекса для каждого сотрудника пришлось бы проверять его зарплату, что значительно медленнее.

*Поиск по диапазону*

Аналогично, если мы ищем сотрудников, чья зарплата находится в определённом диапазоне:

```
SELECT * FROM employees WHERE salary BETWEEN 40000 AND 60000;
```

В этом случае PostgreSQL использует индекс, чтобы быстро находить сотрудников, соответствующих этому диапазону, и не сканировать всю таблицу.

*Сортировка*

При запросе с сортировкой по зарплате:

```
SELECT * FROM employees ORDER BY salary DESC;
```

Пример

На верхнем уровне индекса находится "корневая" страница. Это фиксированная страница метаданных, содержащая указатели на другие страницы на основе хранимых метаданных. Рассмотрим следующий запрос:

```
select numbercol
from numbers n 
where numbercol = 2500;
```

![image](https://github.com/user-attachments/assets/3eff031f-3ca8-4663-82c6-459cf9ed3934)

При перемещении по этому индексу B-Tree для нахождения значения 2500 первой опрашивается корневая страница. Корневая страница содержит первую подсказку на карте для поиска требуемого значения. Значение 2500 больше, чем значение 2001, поэтому корневая страница направляет поиск на правую страницу нелистового (промежуточного) уровня в структуре B-Tree, как показано ниже.

![image](https://github.com/user-attachments/assets/ca617175-9f76-4cba-916b-07f991947b81)

Для нашего поиска значение 2500 находится между 2001 и 3001, поэтому следующей страницей для перехода является листовая страница, содержащая 2001 - 3000, как показано ниже.

![image](https://github.com/user-attachments/assets/bcd70374-a380-4e9e-b615-8be55290689d)

Теперь поиск достиг листового уровня индекса. Для вторичных индексов листовой уровень содержит ключ (ключи) индекса, любые неключевые включенные столбцы, определенные в индексе, и указатель на запись в таблице кучи. 

Для вышеприведенного запроса ядру PostgreSQL необходимо проверить только три страницы, чтобы вернуть затребованные данные. Мы можем это легко проверить с помощью команды EXPLAIN.

```
explain (analyze, buffers) 
select numbercol
from numbers n 
where numbercol = 2500;
```

Рассматривая план запроса ниже, можно заметить, что индекс idx_numbers_numbercol был использован для возвращения одной строки, а для возвращения наших данных было задействовано три общих буфера. Эти три общих буфера соответствуют чтению корневой страницы, нелистовой страницы и листовой страницы для возвращения данных.

![image](https://github.com/user-attachments/assets/644ca6c8-d401-49d3-917b-21aa3f7755fa)

Все индексы в PostgreSQL являются вторичными, это значит, что каждый индекс хранится вне области основных данных таблицы (которая в терминологии PostgreSQL называется кучей таблицы).

Это значит, что при обычном сканировании индекса для извлечения каждой строки необходимо прочитать данные и из индекса, и из кучи. Более того, тогда как элементы индекса, соответствующие заданному условию WHERE, обычно находятся в индексе рядом, строки таблицы могут располагаться в куче произвольным образом. 

Чтобы решить проблему с производительностью, PostgreSQL поддерживает сканирование только индекса, при котором результат запроса может быть получен из самого индекса, без обращения к куче. Основная идея такого сканирования в том, чтобы выдавать значения непосредственно из элемента индекса, и не обращаться к соответствующей записи в куче. Для применения этого метода есть два фундаментальных ограничения:

1. Тип индекса должен поддерживать сканирование только индекса. Индексы-B-деревья поддерживают его всегда.
2. Запрос должен обращаться только к столбцам, сохранённым в индексе. Например, если в таблице построен индекс по столбцам x и y, и в ней есть также столбец z, такие запросы будут использовать сканирование только индекса:

```
SELECT x, y FROM tab WHERE x = 'key';
SELECT x FROM tab WHERE x = 'key' AND y < 42;
```

А эти запросы не будут:
```
SELECT x, z FROM tab WHERE x = 'key';
SELECT x FROM tab WHERE x = 'key' AND z < 42;
```

Если два этих фундаментальных ограничения выполняются, то все данные, требуемые для выполнения запроса, содержатся в индексе, так что сканирование только по индексу физически возможно.



















