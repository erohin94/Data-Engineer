# **Представления**

В контексте баз данных, представление (View) и материализованное представление (Materialized View) — это два типа объектов базы данных, которые используются для упрощения работы с данными. 

# **1. Представление (View):**

Представление — это виртуальная таблица, которая строится на основе SQL-запроса. Оно не хранит данных, а представляет собой результат выполнения запроса каждый раз, когда вы обращаетесь к этому представлению. 
По сути, это сохранённый запрос, который позволяет работать с результатом без необходимости писать его каждый раз. Это как сохранить SQL-запрос, чтобы не писать его снова.

Когда вы выполняете запрос к представлению, база данных выполняет запрос, который был использован для его создания, и возвращает данные, как если бы это была обычная таблица.

Пример:

Есть таблица

```
SELECT * FROM orders ORDER BY customer_id;
```

![image](https://github.com/user-attachments/assets/359b3167-8824-4ed9-8f1d-e8442b2838bb)

Создаем представление с агрегацией.
Которое будет агрегировать данные, например, подсчитывать общее количество заказов и сумму по каждому клиенту:

```
--Создание представления
CREATE VIEW customer_order_summary AS
SELECT customer_id, 
       COUNT(order_id) AS total_orders, 
       SUM(total_amount) AS total_spent
FROM orders
GROUP BY customer_id;
```

После выполенения кода, на боковой панели в папке представление появляется таблица с значком глаза. Это и есть наше представление.

![image](https://github.com/user-attachments/assets/266e21fd-4f22-4044-8004-b754dd6f3841)

Если выполним запрос и в качестве таблицы укажем представление

```
SELECT *
FROM customer_order_summary
ORDER BY customer_id
```

Получим агрегированный результат

![image](https://github.com/user-attachments/assets/1525683b-4ab4-4e27-9c1e-0529de74a761)

Добавим еще данные в таблицу `orders`

```
INSERT INTO orders (customer_id, order_date, total_amount)
VALUES
    (7, '2025-01-07', 200.00),
    (7, '2025-01-08', 400.00);
```

```
SELECT * FROM orders order by customer_id;
```

![image](https://github.com/user-attachments/assets/8044295f-d5c6-4cd6-bd06-64661a8f6635)

Теперь обращаемся к представлению

```
SELECT *
FROM customer_order_summary
ORDER BY customer_id
```

Видим агрегированный результат

![image](https://github.com/user-attachments/assets/a3ada027-184e-4e6e-a79b-5dfa967b1a08)

# **2.Материализованное представление (Materialized View):**

Материализованное представление — это также виртуальная таблица, но в отличие от обычного представления, оно хранит данные. 
Материализованное представление фактически сохраняет результаты запроса в физической таблице и обновляется по расписанию или вручную.

Это означает, что данные в материализованном представлении не пересчитываются каждый раз, как это происходит с обычным представлением. Вместо этого база данных использует сохранённые данные до тех пор, пока не выполнится процесс обновления.

Материализованные представления обычно используются для повышения производительности в тех случаях, когда запросы занимают много времени для выполнения, а данные не меняются часто. Обновление материализованного представления можно настроить на определённые интервалы или делать вручную.

# **Чем они отличаются:**

**Представление (View):**

-Не хранит данные, а динамически генерирует результат при каждом запросе.

-Позволяет работать с данными без необходимости их дублирования в базе.

-При каждом доступе выполняет запрос.

**Материализованное представление (Materialized View):**

-Хранит результат запроса в физической таблице.

-Обновляется вручную или по расписанию.

-Улучшает производительность за счет хранения данных, но требует обновления, если данные изменяются.

# **Запросы для создания и наполнения таблиц**

```
--1.Создание таблицы с PRIMARY KEY, включающим order_date
-- Создаем таблицу заказов с партиционированием по дате
CREATE TABLE orders (
    order_id SERIAL,
    customer_id INT NOT NULL,
    order_date DATE NOT NULL,
    total_amount DECIMAL(10, 2) NOT NULL,
    PRIMARY KEY (order_id, order_date)  -- Включаем order_date в PRIMARY key, если не включить, то будет ошибка
) PARTITION BY RANGE (order_date);

--2.Добавление партиций для каждого месяца
-- Партиция для заказов в январе 2025 года
CREATE TABLE orders_jan_2025 PARTITION OF orders
    FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

-- Партиция для заказов в феврале 2025 года
CREATE TABLE orders_feb_2025 PARTITION OF orders
    FOR VALUES FROM ('2025-02-01') TO ('2025-03-01');

-- Партиция для заказов в марте 2025 года
CREATE TABLE orders_mar_2025 PARTITION OF orders
    FOR VALUES FROM ('2025-03-01') TO ('2025-04-01');

--3.Вставка тестовых данных
-- Вставляем данные для января 2025 года
INSERT INTO orders (customer_id, order_date, total_amount)
VALUES
    (1, '2025-01-05', 150.00),
    (2, '2025-01-15', 200.50),
    (3, '2025-01-20', 99.99);

-- Вставляем данные для февраля 2025 года
INSERT INTO orders (customer_id, order_date, total_amount)
VALUES
    (4, '2025-02-05', 250.00),
    (5, '2025-02-10', 350.75);

-- Вставляем данные для марта 2025 года
INSERT INTO orders (customer_id, order_date, total_amount)
VALUES
    (6, '2025-03-01', 450.00);
```


