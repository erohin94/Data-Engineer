# Идемпотентность в Airflow 

**Идемпотентность** — это когда повторный запуск задачи даёт тот же результат, что и первый. Запусти task 1, 5 или 100 раз — итог не меняется.

Airflow часто перезапускает task-и (retry, backfill, clear), поэтому задачи должны быть безопасными при повторном выполнении.

Чтобы не было: дублей, испорченных/частичных данных, расхождений между витринами, некорректных пересчётов при backfill

**Как сделать task идемпотентным?**

Использовать контекст Airflow:

| Переменная                  | Что означает                                      | Пример значения             |
| --------------------------- | ------------------------------------------------- | --------------------------- |
| `{{ ds }}`                  | Дата запуска DAG в формате `YYYY-MM-DD`           | `2025-11-24`                |
| `{{ data_interval_start }}` | Начало интервала данных, за который работает таск | `2025-11-23T21:00:00+00:00` |
| `{{ data_interval_end }}`   | Конец интервала данных                            | `2025-11-24T21:00:00+00:00` |

```
def load_data(**context):
    start = context["data_interval_start"].format("YYYY-MM-DD")
    end = context["data_interval_end"].format("YYYY-MM-DD")

    url = f"https://api.example.com/data?start={start}&end={end}"

    print(f"Загружаю данные за период: {start} — {end}")
```

Перезаписывать результат, а не добавлять. Сначала временная таблица / temp-файл → затем замена финального результата.

Пример идемпотентного паттерна (DELETE + INSERT)

Например лег таск за `05.11.2025`. Мы его перезапускаем за `05.11.2025` и сохраняем результат в временную таблицу `stg.tmp_target_05_11_2025`.
Далее из витрины (целевой таблицы) дропаем строки с этой датой `05.11.2025`. И в конце вставляем результат из временной таблицы `stg.tmp_target_05_11_2025` в целевую `dm.target_table`

```
-- 1. Создание временной таблицы за дату
CREATE TABLE stg.tmp_target_{{ ds }} AS
SELECT *
FROM source_table
WHERE date = '{{ ds }}';

-- 2. Удаление старых данных в целевой таблице, синтаксис PostgreSQL
DELETE FROM dm.target_table
WHERE date IN (SELECT date FROM stg.tmp_target_{{ ds }});

-- 3. Вставка актуальных данных
INSERT INTO dm.target_table
SELECT * FROM stg.tmp_target_{{ ds }};
```

Повторный запуск даст тот же результат. Нет дублей. Нет порчи данных.

Идемпотентность в Airflow = задача может выполниться много раз, но итог всегда один и тот же.
Это достигается тем, что мы перезаписываем данные за конкретный интервал, а не добавляем новые.

[Пример проекта с идемпотентностью](https://github.com/erohin94/pet_project_earthquake/blob/main/step.md)
